# Аналіз ефективності алгоритмів сортування

## Емпіричні дані

Порівняння часу виконання (в секундах) на різних обсягах даних:

```
Algorithm            | Size       | Time (sec)
--------------------------------------------------
Insertion Sort       | 100        | 0.000119
Merge Sort           | 100        | 0.000131
Timsort (Built-in)   | 100        | 0.000009
--------------------------------------------------
Insertion Sort       | 1000       | 0.016512
Merge Sort           | 1000       | 0.001458
Timsort (Built-in)   | 1000       | 0.000103
--------------------------------------------------
Insertion Sort       | 5000       | 0.357137
Merge Sort           | 5000       | 0.006659
Timsort (Built-in)   | 5000       | 0.000459
--------------------------------------------------
Insertion Sort       | 10000      | 1.430133
Merge Sort           | 10000      | 0.014239
Timsort (Built-in)   | 10000      | 0.001005
--------------------------------------------------
```

## Аналіз результатів

1.  **Insertion Sort:** Ефективний на малих масивах (при n=100 час співставний з Merge Sort). На великих даних показує експоненціальне падіння швидкості, що робить його непридатним для масивів >5000 елементів.
2.  **Merge Sort:** Демонструє стабільну ефективність. Час виконання зростає лінійно-логарифмічно, що робить його надійним для великих даних.
3.  **Timsort:** Найефективніший серед усіх. На масиві n=10000 він у 100 разів швидший за Merge Sort та у 1400 разів швидший за Insertion Sort.

## Висновок

Алгоритм **Timsort** є найефективнішим завдяки поєднанню підходів: він використовує швидкість Insertion Sort на малих підмасивах та ефективність Merge Sort для їх об'єднання.
